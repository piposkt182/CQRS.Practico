using MyApp.Application.Interfaces;
using MyApp.Domain.Entities;
using MyApp.Domain.Interfaces; // Required for IGenderRepository
using System.Threading.Tasks;

namespace MyApp.Application.Commands
{
    public class CreateGenderCommandHandler : ICommandHandler<CreateGenderCommand>
    {
        private readonly IUnitOfWork _unitOfWork;
        // It's common to inject specific repositories if IUnitOfWork doesn't expose them directly,
        // or if the handler needs methods not on IUnitOfWork's repository properties.
        // For now, let's assume IUnitOfWork will provide access to IGenderRepository
        // or that we will add it to IUnitOfWork.
        // If not, we'll inject IGenderRepository directly.

        public CreateGenderCommandHandler(IUnitOfWork unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }

        public async Task HandleAsync(CreateGenderCommand command)
        {
            var gender = new Gender
            {
                Name = command.Name
                // Id is auto-generated by the database
            };

            // Assuming IUnitOfWork has or will have a GenderRepository property
            // If not, this will need adjustment.
            // For example: await _unitOfWork.GenderRepository.AddAsync(gender);
            // Or, if IGenderRepository is injected directly: await _genderRepository.AddAsync(gender);

            // Let's check IUnitOfWork structure first.
            // For now, I'll write the code assuming _unitOfWork.GenderRepository.AddAsync exists.
            // This might require a change to IUnitOfWork or direct injection of IGenderRepository.

            await _unitOfWork.GenderRepository.AddAsync(gender); // This line assumes GenderRepository is on IUnitOfWork
            await _unitOfWork.SaveChangesAsync();
        }
    }
}
